{%extends 'base.html' %}
{% load static from staticfiles %}
{% load compress %}

{%block styles%}
{%compress css%}
<link rel="stylesheet" href="{% static 'css/coc_stw.css'%}" type="text/css" />
<link rel="stylesheet" href="{% static 'css/map.css'%}" type="text/css">
{%endcompress%}
{%endblock%}

{%block scripts%}
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
{%compress js%}
<script src="{% static 'js/underscore.min.js' %}"></script>
<script src="{% static 'js/d3.js' %}"></script>
<script src="{% static 'js/topojson.v1.min.js' %}"></script>
<script src="{% static 'js/queue.v1.min.js' %}"></script>
{%endcompress%}

<script>
var mapWidth = 640,
    mapHeight = 480,
    dataWidth = 250,
    dataHeight = 480,
    active = d3.select(null),
    dataTemplate,
    feNational, feNationalTotal, popNational,
    usMap;

var formatNumber = d3.format(",.0f");
var formatPercent = d3.format(".1%");

// topojson is already projected, display as-is
var path = d3.geo.path()
    .projection(null);

// radius of county bubbles is scaled on sqrt, for area comparisons
var radius = d3.scale.sqrt()
    .domain([0, 15])
    .range([0, 15]);

// pie charts 
var pie = d3.layout.pie()
    .sort(null)
    .value(function(d) { return d.population; });

// main svg object
var mapSvg = d3.select("#map").append("svg")
    .attr("width", mapWidth)
    .attr("height", mapHeight)
    .on("click", stopped, true);

// zoom behavior
var zoom = d3.behavior.zoom()
    .translate([0, 0])
    .scale(1)
    .scaleExtent([1, 8])
    .on("zoom", zoomFunction);

// background rect to allow reset
mapSvg.append("rect")
    .attr("class", "background")
    .attr("width", mapWidth)
    .attr("height", mapHeight)
    .on("click", resetZoom);

// main svg group
var mainGroup = mapSvg.append("g")
    .style("stroke-width", "1.5px");

mapSvg
    //.call(zoom) // allow free zooming
    .call(zoom.event)
    .on('mouseout', initialData);

dataSvg = d3.select("#data").append("svg")
  .attr("width", dataWidth)
  .attr("height", dataHeight);

var dataGroup = dataSvg.append("g")
    .style("stroke-width", "1.5px");

function clickedState(d) {
  if (active.node() === this) { return resetZoom(); }

  active.classed("active", false);
  active = d3.select(this).classed("active", true);

  zoomToState(d);
  $('select[name="states"]').val(Number(d.id));
}

function zoomToState(d) {
    var bounds = path.bounds(d),
      dx = bounds[1][0] - bounds[0][0],
      dy = bounds[1][1] - bounds[0][1],
      x = (bounds[0][0] + bounds[1][0]) / 2,
      y = (bounds[0][1] + bounds[1][1]) / 2,
      scale = .9 / Math.max(dx / mapWidth, dy / mapHeight),
      translate = [mapWidth / 2 - scale * x, mapHeight / 2 - scale * y];

  mapSvg.transition()
      .duration(750)
      .call(zoom.translate(translate).scale(scale).event);
}

function resetZoom() {
  active.classed("active", false);
  active = d3.select(null);

  mapSvg.transition()
      .duration(1000)
      .call(zoom.translate([0, 0]).scale(1).event);

  $('select[name="states"]').val(-1);
}

function zoomFunction() {
  mainGroup.style("stroke-width", 1.5 / d3.event.scale + "px");
  mainGroup.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}

function stopped() {
  if (d3.event.defaultPrevented) d3.event.stopPropagation();
}

// load data files asynchronously
queue()
    .defer(d3.json, "{% static 'data/us.json' %}")
    .defer(d3.json, "{% static 'data/fatalencounters.json' %}")
    .defer(d3.csv, "{% static 'data/doj_focus.csv' %}")
    .await(mergeData);

function mergeData(error, us, fatalencounters, dojFocus) {
  if (error) return console.error(error);
  usMap = us;

  // rollup national numbers
  feNational = d3.nest()
    .key(function(d) { return d.race; })
    .rollup(function(l) { return l.length; })
    .entries(fatalencounters.objects);
  feNationalTotal = d3.sum(feNational, function(d) { return d.values; });
  popNational = d3.sum(us.objects.counties.geometries, function(d) { return d.properties.population; });

  // rollup counties by race
  var feRaceRollup = d3.nest()
    .key(function(d) { return d.county_fips; })
    .key(function(d) { return d.race; })
    .rollup(function(l) { return l.length; })
    .entries(fatalencounters.objects);

  // pull usCounties features from topojson
  var usCounties = topojson.feature(us, us.objects.counties).features;

  // merge FatalEncounters with usCounties
  feByCounty = _.map(usCounties, function(county) {
    feInCounty = _.find(feRaceRollup, function(c) { return c.key === county.id } );
    if (feInCounty) {
      // convert nested rollup array to object 
      byRace = _.object(_.map(feInCounty.values, function(elem) {
        return [elem.key, elem.values];
      }));
      county.properties.fatalencounters = {
        by_race: byRace,
        total: _.reduce(byRace, function(memo, r) { return memo+r; }, 0)
      };
    }
    return county;
  });

  return drawMap(us, feByCounty);
}

function drawMap(us, feByCounty) {

  // draw states
  mainGroup.selectAll("path")
      .data(topojson.feature(us, us.objects.states).features)
    .enter().append("path")
      .attr("d", path)
      .attr("class", "state")
      .on("click", clickedState); // zoom when clicked

  // draw state borders
  mainGroup.append("path")
      .datum(topojson.mesh(us, us.objects.states, function(a, b) { return a !== b; }))
      .attr("class", "border border--state")
      .attr("d", path);

  // draw county bubbles
  mainGroup.append("g")
      .attr("class","bubble")
    .selectAll("circle")
      .data(feByCounty)
    .enter().append("circle")
      .attr("transform", function(d) {
        if (d.geometry) {
          return "translate(" + path.centroid(d) + ")";
        } else {
          return "";
        }
      })
      .attr("r", function(d) {
        return d.properties.fatalencounters ? radius(d.properties.fatalencounters.total) : radius(0);
      })
      .style("visibility", function(d) {
        return d.properties.fatalencounters ? "visible" : "hidden";
      })
      .on("mouseover", updateData)
    /*.append("title")
      .text(function(d) {
        var text = d.properties.name
            + "\nPopulation " + formatNumber(d.properties.population);
        if (d.properties.fatalencounters) {
          text += "\n" + formatNumber(d.properties.fatalencounters.total) + " killed by cops";
          if (d.properties.fatalencounters.by_race['African-American/Black'] !== undefined) {
            pct_black = d.properties.fatalencounters.by_race['African-American/Black'] /
                          d.properties.fatalencounters.total;
            text += "\n- " + formatPercent(pct_black) + " black";
          }
        }
        return text;
      });*/

  initialData();
}

function initialData() {
  // show national numbers
  $('#inner-data').html(dataTemplate({
    name: "Killed by Cops 2000-2014",
    population: formatNumber(popNational),
    fatalencounters: {total: "over "+formatNumber(feNationalTotal)}
  }));
}

function updateData() {
  var data = d3.select(this).data()[0];
  console.log('update',data.properties);
  formatted_data = _.extend({}, data.properties,
    { population: formatNumber(data.properties.population),
      total: formatNumber(data.properties.fatalencounters.total),
    });
  $('#inner-data').html(dataTemplate(formatted_data));
}

function clearData() {
  console.log('clear');
}

d3.select(self.frameElement).style("height", mapHeight + "px");

$(document).ready(function() {
    // set up underscore to do mustache-style templates
  _.templateSettings = {
    interpolate: /\{\{(.+?)\}\}/g
  };

  // compile template
  dataTemplate = _.template($('script#data-template').html());

  $('select[name="states"]').on('change', function() {
    var val = $('select[name="states"]').val();
    if (val !== -1) {
        var state = _.find(mainGroup.selectAll("path").data(), function(d) { return Number(d.id) == val; });

        active.classed("active", false);
        //active = d3.select(state).classed("active", true);

        zoomToState(state);
    } else {
      //active = d3.select(null);
      //resetZoom();
      $('rect.background').click();
    }

  });
});

</script>

<script type = "text/template" id="data-template">
{% verbatim %}
<h2>{{name}}</h2>
<ul>
  <li>Population: {{population}}</li>
  <li>Killed by Cops: {{fatalencounters.total}}</li>
</ul>
{% endverbatim %}
</script>
{%endblock%}

{%block content%}
<div class="map_wrapper">
  <h1>Geography of people killed by law enforcement </h1>
  <h2>Where are people most likely to be killed by police?<br> Why isn't the government collecting this data?</h2>
  <div id="map"></div>
  <div id="data">
    <div id="inner-data"></div>
  </div>
  <em>Click or select a state to zoom in</em>
  <select name="states">
    <option value="-1"></option>
    {% for code in STATE_CODES %}
      <option value="{{code.1}}">{{code.0}}</option>
    {%endfor%}
  </select>
  <p>
    The Killed By Cops map is a project of ColorOfChange.org with data from FatalEncounters.org developed to visualize the crisis of violent policing and to call attention to the lack of a comprehensive, publicly-accessible, national database that tracks deadly encounters with police. The data is crowdsourced by FatalEncounters because many local police departments are not required to report this data to the DOJ, meaning that the dataset is largely incomplete and the lack of heated bubble areas is as result of the lack of available data and not because these areas are exempt from the epidemic of police violence and killings.
  </p>
  <ul id="sources">
    <li>News Reports from 2000-2014 collected by <a href="http://www.fatalencounters.org">FatalEncounters.org</a></li>
    <li>Population from <a href="http://factfinder2.census.gov">US Census</a>, 2012 American Community Survey
    <li>Conduct of Law Enforcement cases <a href="http://www.justice.gov/crt/about/spl/findsettle.php">Department of Justice</a>
    <li>Mapping and data analysis by <a href="http://colorofchange.org">ColorOfChange.org</a></li>
  </ul>
</div>
{%endblock%}